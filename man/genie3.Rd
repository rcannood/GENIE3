% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/genie3.R
\name{genie3}
\alias{genie3}
\title{Compute weighted adjacency matrix of inferred network}
\usage{
genie3(data, K = "sqrt", nb.trees = 1000,
  regulators = seq_len(ncol(data)), targets = seq_len(ncol(data)),
  importance.measure = "IncNodePurity", seed = NULL, trace = TRUE,
  mc.cores = 1)
}
\arguments{
\item{data}{A matrix of observations of the different features. The rows must contain the observations.}

\item{K}{The choice of number of input genes randomly selected as candidates at each node. Must be "all" for all input features, "sqrt" for the square root of all input features (default), or an integer.}

\item{nb.trees}{The number of trees in ensemble for each target gene (default 1000).}

\item{regulators}{A set of indices or column names of entities whose observed values regulate the observed values of the targets.}

\item{targets}{A set of indices or column names of entities whose observed values are regulated by the regulators.}

\item{importance.measure}{Type of variable importance measure. Must be either "IncNodePurity" for the importance measure based on decrease of residual sum of squares, or "%IncMSE" for importance measure optained by permutation of OOB data."}

\item{seed}{A random number generator seed for replication of analyses. NULL means the seed is not set.}

\item{trace}{Output additional information.}

\item{mc.cores}{The number of threads to use for parallel execution.}
}
\value{
The weighted adjacency matrix of inferred network.
}
\description{
Compute weighted adjacency matrix of inferred network
}
\examples{
weights <- genie3(expr.matrix, regulators=1:5, targets=6:10, mc.cores=8)
ranking <- get.ranking(weights)
evaluation <- evaluate.ranking(ranking, true.matrix=true.matrix)
evaluation$au.score

# ROC curve
library(ggplot2)
ggplot(evaluation$ranked.df, aes(fpr, rec)) + geom_line() + coord_cartesian(xlim = c(0, 1), ylim=c(0, 1))

# PR curve
ggplot(evaluation$ranked.df, aes(rec, prec)) + geom_line() + coord_cartesian(xlim = c(0, 1), ylim=c(0, 1))
}

